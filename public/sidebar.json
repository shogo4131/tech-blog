{"tags":[{"id":"eslint","createdAt":"2022-11-11T05:28:27.328Z","updatedAt":"2022-11-11T05:28:27.328Z","publishedAt":"2022-11-11T05:28:27.328Z","revisedAt":"2022-11-11T05:28:27.328Z","tag":"ESLint"},{"id":"javascript","createdAt":"2022-11-11T05:27:35.652Z","updatedAt":"2022-11-11T05:27:35.652Z","publishedAt":"2022-11-11T05:27:35.652Z","revisedAt":"2022-11-11T05:27:35.652Z","tag":"JavaScript"},{"id":"other","createdAt":"2022-09-20T13:15:22.021Z","updatedAt":"2022-10-20T09:22:45.919Z","publishedAt":"2022-09-20T13:15:22.021Z","revisedAt":"2022-09-20T13:15:22.021Z","tag":"その他"},{"id":"typescript","createdAt":"2022-10-20T09:17:30.354Z","updatedAt":"2022-10-20T09:17:30.354Z","publishedAt":"2022-10-20T09:17:30.354Z","revisedAt":"2022-10-20T09:17:30.354Z","tag":"TypeScript"},{"id":"react","createdAt":"2022-10-20T09:16:54.710Z","updatedAt":"2022-10-20T09:16:54.710Z","publishedAt":"2022-10-20T09:16:54.710Z","revisedAt":"2022-10-20T09:16:54.710Z","tag":"React"}],"categories":[{"id":"others","createdAt":"2022-09-13T11:39:10.766Z","updatedAt":"2022-10-20T09:40:18.437Z","publishedAt":"2022-09-13T11:39:10.766Z","revisedAt":"2022-09-20T13:28:44.688Z","category":"その他","post":[{"id":"first-post","createdAt":"2022-09-20T13:13:01.142Z","updatedAt":"2022-10-11T10:18:57.796Z","publishedAt":"2022-09-21T08:11:04.538Z","revisedAt":"2022-10-11T10:18:57.796Z","title":"初投稿！今後のブログ運用について","body":"<p>初めまして！<br>Reactおじさんです。<br><br>7月から取り組んでいた技術ブログがようやくリリースできる形になったので、<br>最低限の機能だけ作ってリリースしました笑(バテたので最低限になってしまった…)<br></p><h2 id=\"h2ba0511ec3\">なぜ技術ブログを作ろうと思ったのか</h2><p>理由はたくさんありますが、厳選して下記3点にまとめてみました！<br><br></p><ul><li>アウトプットできる環境が欲しかった</li><li>転職やカジュアル面談時にアピールできるものが欲しかった</li><li>0から自分のサービスを作ってみたかった</li></ul><p><br></p><h3 id=\"h7216114e93\">アプトプットできる環境が欲しかった</h3><p>結論から言うと、アウトプットした方が知識の定着度が段違いだったことです。<br><br>今までは個人のGithubなどで、ソースを書くくらいしか行ってなかったのですが、<br>人に教えたりする際に、全然言語化できませんでした、、<br><br>言語化をして、分かりやすく人に伝えれて初めて理解したと言えるので、<br>このブログを機に言語化能力を高めようかと思います。<br><br></p><h3 id=\"hc6025208ab\">転職やカジュアル面談時にアピールできるものがほしかった</h3><p>ここ数ヶ月、カジュアル面談に励んでいましたが、<br><br>「個人開発でブログ作ってます！！」、「勉強会で講師やってます！！」<br><br>など話すと、面接官がとても喜んでくれました笑<br>さらに、ブログの内容次第では自分の技術力もアピールできるので、一石二鳥ですね！<br><br></p><h3 id=\"hcee798f356\">0から自分のサービスを作ってみたかった</h3><p>これは、エンジニアになった時から目標にしていた事なんですが、<br>自分でサイトを作って世に公開するという目標が地味にありました。<br><br>2年半程かかってしまいましたが、、笑<br></p><h2 id=\"he235b92c3c\">ブログの技術スタック</h2><p>今回は運用費用を0円にしたかったので、<br>下記のような構成にしました！<br></p><ul><li>Next.js</li><li>CSS Module</li><li>microcms </li><li>Storybook</li><li>Netflify </li></ul><p><br>使った事ない技術が半分くらいあったので、中々手こずりました。。<br></p><h2 id=\"h3bfc3925d3\">今後の方針について</h2><p>とりあえずブログの機能追加をしつつ、記事を量産してければなと思っています。<br><br>最初の方は、フロントエンド向けの記事を増やしつつ、バックエンド・インフラの記事も<br>公開していく予定です！<br><br><br><br>年内に1<strong>0記事</strong>は投稿できるようにしたい。。。</p>","thumbnail":{"url":"https://images.microcms-assets.io/assets/92d5d05a58d743f0abd69ff4e6ea61a5/33883284dba14874a5ef4e0dbab0f1e8/cropPAK86_pennotekakikomi20140312.jpg","height":600,"width":1200},"description":"Reactおじさんがエンジニアとして学習した事をアウトプットしていくブログです。ブログを作った背景、今後の展望を記載します。","tags":[{"id":"other"}],"category":[{"id":"others"}]}]},{"id":"frontend","createdAt":"2022-10-20T09:14:38.518Z","updatedAt":"2022-11-11T05:27:05.766Z","publishedAt":"2022-10-20T09:14:38.518Z","revisedAt":"2022-11-11T05:27:05.766Z","category":"フロントエンド","post":[{"id":"use-react-componentprops-type","createdAt":"2022-10-20T09:07:53.537Z","updatedAt":"2022-10-21T13:47:16.972Z","publishedAt":"2022-10-20T09:18:50.802Z","revisedAt":"2022-10-21T13:47:16.972Z","title":"ReactのComponentProps型を使って不要なPropsとお別れしよう！！","body":"<p>どうもReactおじさんです。<br><br>ブログをリリースして満足していましたが、記事を執筆しないと価値が無くなってしまうので、だらけずにアプトプットしていこうと思います。<br><br>今回は汎用コンポーネントの作り方です。<br></p><h2 id=\"h22ff7066ae\">一般的な汎用コンポーネントの作り方</h2><p>フロントエンドエンジニアであればコンポーネント作成は避けて通れない道ですよね、、<br><br>今回のメインに行く前に一般的に作られているコンポーネントの作り方をおさらいしましょう。<br><br></p><h3 id=\"he0a8675f39\">ボタンコンポーネントの場合</h3><pre><code>import type { FC, ReactNode } from \"react\";\n\ntype Props = {\n  children: ReactNode;\n  onClick: () =&gt; void;\n};\n\nexport const Button: FC&lt;Props&gt; = ({ children, onClick }) =&gt; {\n  return &lt;button onClick={onClick}&gt;{children}&lt;/button&gt;;\n};</code></pre><p><br></p><h3 id=\"h458ac61db2\">テキストフィールドコンポーネントの場合</h3><pre><code>import type { ChangeEventHandler, FC } from \"react\";\n\ntype Props = {\n  value: string | number;\n  onChange: ChangeEventHandler&lt;HTMLInputElement&gt;;\n};\n\nexport const TextFiled: FC&lt;Props&gt; = ({ value, onChange }) =&gt; {\n  return &lt;input type=\"text\" value={value} onChange={onChange} /&gt;;\n};</code></pre><p><br>ボタンコンポーネントはクリックが可能。<br>テキストフィールドコンポーネントは入力が可能な最低限の機能を備えています。<br><br>では次に、ボタンコンポーネントにボタンのタイプ、活性 or 非活性の機能を追加してみましょう。<br></p><pre><code>import type { FC, ReactNode } from \"react\";\n\ntype Props = {\n  children: ReactNode;\n  onClick: () =&gt; void;\n  disabled: boolean; // 追加\n  type: \"button\" | \"reset\" | \"submit\"; // 追加\n};\n\nexport const Button: FC&lt;Props&gt; = ({ children, onClick, type, disabled }) =&gt; {\n  return (\n    &lt;button type={type} onClick={onClick} disabled={disabled} &gt;\n      {children}\n    &lt;/button&gt;\n  );\n};</code></pre><p><br>disabledとtypeを追加しました。<br>上記の様に何か機能を追加したい時は、ボタンコンポーネントの修正・ボタンコンポーネントを呼び出している親コンポーネントの修正が必要になります。<br><br>一見普通に見えますが、テキストフィールドコンポーネントの場合id、onBulr、name、onKeyDown等の要素やイベントを必要になった時に追加していくのはメンテコストがかかるし受け取るPropsの型定義が冗長になっていきます。<br><br>そこで次に出てくる<strong>ComponentProps</strong>型が救世主となります。<br></p><h2 id=\"h49c99ca828\">ComponentProps型を使用した汎用コンポーネントの作り方</h2><p>ComponentProps型とは、簡単に説明すると指定したコンポーネントのProps型を取得できる型です。<br><br>↓こんな感じ</p><pre><code>type Props = ComponentProps&lt;typeof Button&gt;;</code></pre><p><br><img src=\"https://images.microcms-assets.io/assets/92d5d05a58d743f0abd69ff4e6ea61a5/2cd2e5c370cc44659337313de7847da3/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202022-10-19%2020.31.43.png\" alt=\"\"><br><br>例えば、先ほどのボタンコンポーネントをComponentProps型に指定すると、<br>ボタンコンコーネントのPropsの型を全て取得できます。<br><br>では、先ほどのボタン・テキストフィールドコンポーネントを修正していきます。<br><br></p><h3 id=\"h75643da8d3\">ボタンコンポーネントの場合(ComponentProps ver)</h3><pre><code>import type { FC, ReactNode, ComponentProps } from \"react\";\n\ntype Props = {\n  children: ReactNode;\n} &amp; ComponentProps&lt;\"button\"&gt;;\n\nexport const Button: FC&lt;Props&gt; = ({ children, ...props }) =&gt; {\n  return &lt;button {...props}&gt;{children}&lt;/button&gt;;\n};</code></pre><p><br>親コンポーネント</p><pre><code>import { Button } from \"../components/button\";\n\nconst Index = () =&gt; {\n  const onClickHandler = () =&gt; console.log(\"click\");\n\n  return (\n    &lt;Button type=\"button\" onClick={onClickHandler}&gt;\n      テスト\n    &lt;/Button&gt;\n  );\n};\n\nexport default Index;</code></pre><p><br></p><h3 id=\"h2deda0682e\">テキストフィールドコンポーネントの場合(ComponentProps ver)</h3><pre><code>import type { ComponentProps, FC } from \"react\";\n\ntype Props = ComponentProps&lt;\"input\"&gt;;\n\nexport const TextFiled: FC&lt;Props&gt; = ({ ...props }) =&gt; {\n  return &lt;input {...props} /&gt;;\n};</code></pre><p><br>親コンコーネント</p><pre><code>import { ChangeEvent, useState } from \"react\";\nimport { TextFiled } from \"../components/textFiled\";\n\nconst Index = () =&gt; {\n  const [value, setValue] = useState(\"\");\n\n  const onChangeHandler = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt;\n    setValue(e.target.value);\n\n  return &lt;TextFiled value={value} onChange={onChangeHandler} /&gt;;\n};\n\nexport default Index;</code></pre><p><br>順番に見ていきましょう。<br></p><ol><li>ボタン、テキストフィールドコンポーネント両方に<strong>ComponentProps</strong>を追加</li><li>受け取るPropsをスプレット構文で一括に受け取れるように修正</li><li>受け取ったPropsを各要素に追加</li></ol><p><br>まず1ですが、ComponentProps型を追加してボタンの要素(type,onClick,disabled等)、テキストフィールドの要素(type,onChange,value等)の型を全て受け取っています。<br><br>そして2と3で受け取ったPropsを展開していている形になっています。<br><br>これで親コンポーネントからPropsを渡してもボタン、テキストフィールドコンポーネントは修正せずに済むのでメンテコストがかからずコード量も削減できました。<br><br>ただし、Reactのinput要素はonChange、valueが必須なのでその場合は、下記の様にOmitでComponentPropsから必要な型は除外して、明示的にPropsの型定義を書くことでバグを回避するようにしましょう。<br></p><pre><code>import type { ChangeEventHandler, ComponentProps, FC } from \"react\";\n\ntype Props = {\n  value: string | number;\n  onChange: ChangeEventHandler;\n} &amp; Omit&lt;ComponentProps&lt;\"input\"&gt;, \"value\" |  \"onChange\" &gt;;\n\nexport const TextFiled: FC&lt;Props&gt; = ({ value, onChange, ...props }) =&gt; {\n  return &lt;input {...props} value={value} onChange={onChange} /&gt;;\n};</code></pre><p><br></p><h2 id=\"ha214098e44\">まとめ</h2><ul><li>ComponentProps型は指定したコンポーネントの型を全て取得できる</li><li>普通のHTMLタグの振る舞いをしてほしい場合は、ComponentPropsで型定義した方がメンテコスト、ソース量が削減できる</li><li>コンポーネントに必須な型はOmit等でComponentPropsから除外し、明示的にPropsの型定義をしてバグを防ぐ</li></ul><p><br><br>公式ドキュメントに載っていなかったので理解するのに時間がかかりました、、<br><br>間違っている部分、分かりにくい部分は<a href=\"https://twitter.com/react_nextjs\" target=\"_blank\" rel=\"noopener noreferrer\">Twitter</a>でDMお願いします。<br><br></p>","thumbnail":{"url":"https://images.microcms-assets.io/assets/92d5d05a58d743f0abd69ff4e6ea61a5/dc10b60546504ea99a6b5b7a3e7e3435/react.webp","height":300,"width":600},"description":"ReactのComponentProps型について解説してきます。一般的なコンポーネントの作り方から、ComponentProps型を使用したコンポーネントの作成を行い不要なPropsを取り除く事ができます。","tags":[{"id":"react"},{"id":"typescript"}],"category":[{"id":"frontend"}]},{"id":"react-state-management","createdAt":"2022-11-03T09:29:49.166Z","updatedAt":"2022-11-10T07:40:46.440Z","publishedAt":"2022-11-03T09:41:48.135Z","revisedAt":"2022-11-03T11:31:14.891Z","title":"Reactの状態管理ライブラリを比較してベストな選択をしよう！","body":"<p>どうもReactおじさんです。<br><br>昨今のReact、Next.jsの進化の早さにはとても驚いています。<br>それはReactに追従するライブラリも同様です。<br><br>特にReactの状態管理ライブラリは戦国時代を迎え、様々な状態管理ライブラリが台頭してきました。<br><br>今回はライブラリの紹介、これから使用されていくであろう物にフォーカスして自分なりにまとめてみようと思います。<br></p><h2 id=\"h79b411f1c1\">結局、状態管理ライブラリは何が人気なのか？？</h2><p>JavaScript Rising StartsのState Management部門(2021)とnpm trendsを見ていきましょう。<br><br></p><h3 id=\"hb15961a87d\">JavaScript Rising Starts</h3><p><img src=\"https://images.microcms-assets.io/assets/92d5d05a58d743f0abd69ff4e6ea61a5/46b7957e1574411d815c901bf7a3570f/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202022-11-02%2019.27.22.png\" alt=\"\"><br>※ <a href=\"https://risingstars.js.org/2021/en#section-statemanagement\" target=\"_blank\" rel=\"noopener noreferrer\">JavaScript Rising Starts</a>とはGithubのスター数でのランキングをまとめたもの<br><br></p><h3 id=\"ha421048148\">npm trends</h3><p><img src=\"https://images.microcms-assets.io/assets/92d5d05a58d743f0abd69ff4e6ea61a5/6f482c67016f458db6892ccd0bac23d4/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202022-11-02%2019.36.09.png\" alt=\"\"><br>※<a href=\"https://npmtrends.com/jotai-vs-recoil-vs-redux-vs-valtio-vs-zustand\" target=\"_blank\" rel=\"noopener noreferrer\"> npm trends</a>とはnpmからダウンロードされたパッケージの数をグラフ表示出来るもの(2022/11/2時点)<br><br>JavaScript Rising StartsではZustandが圧倒的な人気で一位を獲得しています。<br>最近よく耳にする、Recoil・Jotaiも上位に食い込んできています。<br>Reduxは6位とやや後退気味ですね、、<br><br>一転、npm trendsでは70万ダウンロードされているReduxが圧勝。<br>Zustandなどはまだまだこれからって感じですね、、<br><br>Reduxは10年前くらいからあったのでダウンロード数が多いが、最近では他のライブラリの勢いが増してきて人気が落ちてきていますね。<br><br>では、次にStore・Atomベースについて解説し、各ライブラリの情報を見ていきたいと思います。<br></p><h2 id=\"h4d05cf9f01\">Storeベースの状態管理ライブラリ</h2><p>まず最初にStoreベースとは何か図で解説していきます。<br><img src=\"https://images.microcms-assets.io/assets/92d5d05a58d743f0abd69ff4e6ea61a5/2a7de941b18f451d9a69243632a6af31/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202022-11-02%2023.23.28.png\" alt=\"\"><br>青丸はコンポーネントになります。<br><br>Storeベースとは状態をStoreという一つのオブジェクトとして管理し、各コンポーネントから参照できることを言います。<br><br>よく使われるライブラリとして<strong>Redux</strong>、<strong>Zustand</strong>などがあります。<br><br></p><h3 id=\"h227615658d\">Redux</h3><p>公式: <a href=\"https://redux.js.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://redux.js.org/</a><br></p><ul><li>Facebook(現Meta)社が提唱している、Fluxアーキテクチャを採用している</li><li>単一方向にデータが流れていくので、データの流れを追従しやすくなる</li><li>大規模なアプリではより堅牢化できるので力を発揮できる</li><li>Action、Dispatch、Reducer、Storeなどファイルを分割して管理するのが一般的でファイル数が増加するのが問題</li><li>恐らく一番最古残でシェア率が高い状態管理ライブラリ</li><li>Reduxで非同期処理を実現させるには、別でmiddllewareライブラリ(redux-thunk、redux-saga)を導入した方がいい。</li><li>どうしても初学者には学習コストが高くなってしまう。</li><li><a href=\"https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd\" target=\"_blank\" rel=\"noopener noreferrer\">Redux DevTools</a>というChromeの拡張機能があり、状態の変更を画面で確認できる</li></ul><p><br>オススメ度: ★★☆☆☆<br><br>状態管理の流れを単一方向の流に絞れるのでバグが発生する可能性を大幅に削減できます。<br><br>しかし、ファイル数の増加や、複雑になってくることが多いため個人的にはあまり使用したくないです。<br><br>最近は、新規開発で導入するところはあまり見なくなってきて、脱Reduxが進んでいます。<br><br>Storeに全データをぶち込む人とは仲良くできそうにありません。笑<br><br></p><h3 id=\"h7526918382\">Zustand</h3><p>公式: <a href=\"https://zustand-demo.pmnd.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">https://zustand-demo.pmnd.rs/</a><br></p><ul><li>公式のクマさん(?)が可愛いです</li><li>Reduxのようなボイラーテンプレートを作成する必要がなく簡潔に記述できる(Redux-Toolkitをさらに簡潔にした感じ)</li><li><a style=\"background-color:#ffffff\" href=\"https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd\" target=\"_blank\" rel=\"noopener noreferrer\">Redux DevTools</a>にも対応している</li><li>Reduxを理解している人だと、学習コストがほぼかからない</li><li>サイズがめちゃくちゃ軽い</li><li>一応Storeが複数作れるらしい</li></ul><p><br>オススメ度: ★★★★☆<br><br>個人的には結構オススメな状態管理ライブラリ。<br><br>公式のクマさんが可愛過ぎて推しているところもあります。<br><br>Storeが複数作れるので完全なStoreベースとは言えませんが一応括りはここに入れておくことに。<br><br>StoreベースとAtomベースの中間地点だと認識してもらえると幸いです。<br><br>Reduxをさらにコンパクトにしたもので、Reduxから置き換える時に学習コストがほぼかからないのでオススメの一品。<br><br>読み方はドイツ語で「<span style=\"color:#333333\">チュースタンド」と読むらしいです。</span><br><br></p><h2 id=\"h3e55398a54\">Atomベースの状態管理ライブラリ</h2><p>次にAtomベースについて解説していきます。<br><img src=\"https://images.microcms-assets.io/assets/92d5d05a58d743f0abd69ff4e6ea61a5/00004adda2254de994f0ac396c194830/%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%B3%E3%82%B7%E3%83%A7%E3%83%83%E3%83%88%202022-11-02%2023.33.12.png\" alt=\"\"><br><br>Atomベースとは、Storeベースとは異なり複数のAtomで状態管理を行うことを言います。<br><br>各コンポーネントから複数のAtomを参照できる形になります。<br><br>必要であれば間にSelectorを挟み、Atomのデータを加工してそちらからも参照可能です。<br><br>よく使われるライブラリとして<strong style=\"background-color:#ffffff\">Recoil</strong>、<strong style=\"background-color:#ffffff\">Jotai</strong>などがあります。<br><br></p><h3 id=\"hc41e2fe005\">Recoil</h3><p>公式: <a href=\"https://recoiljs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://recoiljs.org/</a><br></p><ul><li>Meta社が開発した状態管理ライブラリ</li><li>大きく分けてAtom、Selectorという概念がある</li><li>基本はAtomのみで状態管理は完結できる</li><li>Atomが状態管理を行う部分、SelectorはAtomから派生させたい値を作りたい時とかに利用できる</li><li>Atomを一つにまとめてReduxのStoreのように扱うこともできる</li><li><a href=\"https://chrome.google.com/webstore/detail/recoil-dev-tools/dhjcdlmklldodggmleehadpjephfgflc\" target=\"_blank\" rel=\"noopener noreferrer\">Recoil Dev Tools</a>があり、Atomの状態を確認できる</li><li>hooksのuseStateの様な形式でAtomから状態を参照できる</li></ul><p><br>オススメ度: ★★★☆☆<br><br>Meta社が開発した状態管理ライブラリ。<br><br>まだ正式リリースではないので今後破壊的変更が入る可能性があるが、最近は開発現場でよく使用されている印象があります。<br><br>状態を一意のkeyを使って管理するので、uuidなどを使用しkeyが被らないようにするのが良いです。<br>(勉強会で教えてもらった)<br><br>パッケージサイズがやたらと重いので複雑な状態管理が必要でなければこの後出てくる<strong>Jotai</strong>でも良い気がします。<br><br>バックグラウンドがMeta社なので将来性は期待できそうです！<br><br></p><h3 id=\"he797c16ec4\">Jotai</h3><p>公式: <a href=\"https://jotai.org/\" target=\"_blank\" rel=\"noopener noreferrer\">https://jotai.org/</a><br></p><ul><li>ほぼRecoilと一緒(Recoilより簡潔に記述できる)</li><li>基本Atomが状態管理を行う部分。Selector的なものはないがRecoilと同じでSelectorとほぼ同等のものが作れる</li><li><a style=\"background-color:#ffffff\" href=\"https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd\" target=\"_blank\" rel=\"noopener noreferrer\">Redux DevTools</a>が使用できる</li><li>Twitterでのサポートが熱い(<a href=\"https://twitter.com/jotaifriends\" target=\"_blank\" rel=\"noopener noreferrer\">Jotai Friends</a>)</li></ul><p><br>オススメ度: ★★★★☆<br><br>作者は日本人なので日本語の情報が豊富で公式ドキュメントも詳細に記載されている。<br><br>JotaiはRecoilの思想に強く影響を受けており、ほぼRecoilと同じ書き方ができる。<br><br>個人的にはパッケージサイズも小さく、React Hooksを学んでいる人であれば学習コストがほぼかからないのでオススメです。<br><br></p><h2 id=\"ha214098e44\">まとめ</h2><p>ここまで人気が高い状態管理ライブラリを紹介してきました。<br><br>色々調査した中で、個人的な所感も含め記載してきましたが、Atomベースは状態管理を複数のAtomで行うためしっかり管理しないとカオスなコードが生まれそうな予感がしました。<br><br>どちらにしろ状態管理ライブラリを扱うには設計が命になってくるので、個人のプロジェクトにあったものをできるだけ正確に選定する力が必要になってくるなと思います。<br><br>ちなみに筆者は紹介したライブラリ全て使用した経験がありますが、一番使いやすいなと思ったのは<strong>Jotai</strong>でした。<br><br>他にもSWRやReact Queryなどで状態管理する方法もありますが今回は省いています。<br><br>今後はRedux、Zustandなどの記事も書いていこうと思います。<br><br>あくまで個人の所感なので間違っている部分があればTwitterなどでDMください。<br><br><br><br><a href=\"https://valtio.pmnd.rs/docs/introduction/getting-started\" target=\"_blank\" rel=\"noopener noreferrer\">Valtio</a>使ってみたい、、、<br><br><br></p>","thumbnail":{"url":"https://images.microcms-assets.io/assets/92d5d05a58d743f0abd69ff4e6ea61a5/dc10b60546504ea99a6b5b7a3e7e3435/react.webp","height":300,"width":600},"description":"Reactの状態管理ライブラリについて考察していきます。StoreベースのRedux・Zustand、AtomベースのRecoil・Jotaiについての特徴を解説します。この記事を読むことで要件にあったライブラリを選定できる参考になればと思います。","tags":[{"id":"react"}],"category":[{"id":"frontend"}]},{"id":"eslint-rule-no-nested-ternary","createdAt":"2022-11-11T05:26:32.746Z","updatedAt":"2022-11-11T06:28:29.415Z","publishedAt":"2022-11-11T06:26:50.618Z","revisedAt":"2022-11-11T06:28:29.415Z","title":"ESLintのno-nested-ternaryを使用して三項演算子の可読性を担保しよう!","body":"<p>どうもReactおじさんです。<br>先日、三項演算子についてツイートした際に反響があったので詳しく深掘りしていこうと思います。<br></p><blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">たまに三項演算子の中に三項演算子を書く人がいるけど可読性悪すぎてNGな気がする。<br>基本、１つの三項演算子で解決できないのであればif文使って書いた方が良い。</p>&mdash; Reactおじさん (@react_nextjs) <a href=\"https://twitter.com/react_nextjs/status/1589819315716788224?ref_src=twsrc%5Etfw\">November 8, 2022</a></blockquote><script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script><p>特に初学者の方には刺さる内容だと思うので最後まで読んで、現場で今回解説する出来事があればこの記事の内容を元にドヤってみてください。<br></p><h2 id=\"h407456acd2\">三項演算子とは</h2><p>三項演算子が分からない方向けに軽く解説します。<br>めちゃくちゃ噛み砕いて説明すると、<strong>if 〜 else 〜 </strong>と書きたい時に一文で済ませる演算子のことです。<br><br>if文の場合</p><pre><code>const num = 4\n\nif (num === 4) {\n  // 真の処理\n} else {\n  // 偽の処理\n}</code></pre><p><br>三項演算子の場合</p><pre><code>const num = 4\n\nnum === 4 ? /* 真の処理 */ : /* 偽の処理 */</code></pre><p>三項演算子の場合、if文と比べて一文で記載できるので可読性が良くなりましたね！<br><br>では、次に三項演算子の入れ子について見ていきましょう。<br></p><h2 id=\"ha7d379640e\">なぜ入れ子になった三項演算子がダメなのか</h2><p>まずは入れ子になった三項演算子とはどのようなものかサンプルを作りました。<br><br>入れ子の三項演算子</p><pre><code>const num = 4;\nconst num1 = 5;\n\nnum === 4\n  ? console.log('4です')\n  : num1 === 5\n  ? console.log('5です')\n  : console.log('4でも5でもないです');</code></pre><p>一つずつ確認していきましょう。<br><br>まず、numが4の時は「4です」がログに表示されます。<br>numが4じゃない時は、num1が5であれば「5です」が表示され、num1が5でない時は「4でも5でもないです」がログに表示される三項演算子になります。<br><br>めちゃくちゃ読みづらいですよね、、<br>自分でサンプル作ってても可読性悪すぎて頭が混乱してきましたw<br><br>この程度の簡単な処理であれば最悪読めなくもないのですが、これがReactのJSX内で記述されていた時には中々読み取るのに時間もストレスもかかってしまうでしょう、、<br><br>Twitterでも記載しましたが、入れ子になる場合はif文を使用して可読性を高めましょう。<br><br>入れ子になった三項演算子をif文で書いた場合</p><pre><code>const num = 4;\nconst num1 = 5;\n\nif (num === 4) {\n  console.log('4です');\n} else if (num1 === 5) {\n  console.log('5です');\n} else {\n  console.log('4でも5でもないです');\n}</code></pre><p>入れ子になっていた時よりもソース量は若干増えますが、パッと見た時になんの処理を書いているのかすぐにわかるようになりました。<br></p><h2 id=\"hd8969f652e\">ESLintのno-nested-ternaryルールを使用する</h2><p>ここで三項演算子の入れ子をした時にエラーを出すESLintのルール<strong>no-nested-ternary</strong>を紹介します。<br>公式: <a href=\"https://eslint.org/docs/latest/rules/no-nested-ternary\" target=\"_blank\" rel=\"noopener noreferrer\">no-nested-ternary</a><br><br>ESLint自体の詳細は割愛させていただきますが、eslint.json,yml,jsなどのrulesに1行追加するだけです。(eslintはnpm installする必要あり)<br><br>eslint.json</p><pre><code>{\n\t  \"parser\": \"@typescript-eslint/parser\",\n\t  \"plugins\": [\"import\", \"@typescript-eslint\", \"prettier\"],\n\t  \"ignorePatterns\": [\"*.config.js\", \"*.setup.js\", \"*.js\"],\n\t  \"extends\": [\n\t    \"eslint:recommended\",\n\t    \"next\",\n\t    \"plugin:@typescript-eslint/recommended\",\n\t    \"plugin:@typescript-eslint/recommended-requiring-type-checking\",\n\t    \"plugin:import/recommended\",\n\t    \"prettier\"\n\t  ],\n\t  ...\n\t  \"rules\": {\n\t   ...\n            \"no-nested-ternary\": \"error\", // 追加\n\t   ...\n  \t  }\n}</code></pre><p><br>エディタでエラーが出ているか確認<br><img src=\"undefined\" alt=\"\"><br>入れ子になった場合はエラーが出てますね！<br></p><h2 id=\"ha214098e44\">まとめ</h2><p>三項演算子について色々書いてきましたが、基本<strong style=\"background-color:#ffffff\">if 〜 else 〜 </strong>の場合は使用した方がよく、入れ子になる際は<strong style=\"background-color:#ffffff\">if文</strong>を使用しましょう。<br><br>プロジェクトによっては、そもそも三項演算子を禁止して全部if文で書くところもあるそうです。<br><br>大事なのはケースバイケースで使い分けれることだと思います。<br><br>プロジェクトでメンバーのスキルがバラバラな場合は、<strong style=\"background-color:#ffffff\">no-nested-ternary</strong>を使用し、ルールを統一してソースコードの品質を担保していきましょう。<br><br>これはJavaScriptのみにならず、三項演算子が使用される言語全てに共通していることなので是非参考にしてみてください。<br><br><br>間違っている部分やもっと良い方法があればTwitterでDMお願いします。<br><br><br></p>","thumbnail":{"url":"https://images.microcms-assets.io/assets/92d5d05a58d743f0abd69ff4e6ea61a5/dc10b60546504ea99a6b5b7a3e7e3435/react.webp","height":300,"width":600},"description":"ESLintのルールno-nested-ternaryについて言及していきます。このルールは三項演算子の入れ子を禁止するルールです。三項演算子の入れ子は可読性が悪いのでプロジェクトで見かけたらこのルールを入れてソースコードの可読性を担保しましょう。","tags":[{"id":"javascript"},{"id":"eslint"}],"category":[{"id":"frontend"}]}]}]}
